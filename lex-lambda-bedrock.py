
import json
import boto3
import os

def lambda_handler(event, context):

    session_state = event.get('sessionState', {})
    session_attributes = session_state.get('sessionAttributes', {})
    session_id_kb = session_attributes.get('sessionId_kb', None)  # KB wants to generate its own sessions ID
    session_id = event.get('sessionId', None) # comes from Lex/WebUI, we will use it for Agent session ID
    
    input_text = event.get('inputTranscript', None)
    
    agent_id=os.environ.get('agent_id', None)
    agent_alias_id=os.environ.get('agent_alias_id', None)
    kb_id=os.environ.get('kb_id', None)
    model_id=os.environ.get('model_id', None)
    
    runtime_client=boto3.client( service_name="bedrock-agent-runtime" )
    
    # If KB is defined then use KB, otherwise - call agent
    
    if kb_id and model_id:
        
        # Using KB
        
        model_arn = f'arn:aws:bedrock:us-east-1::foundation-model/{model_id}'
        
        if session_id_kb:
            # this is a subsequent call to KB, we already have session_id generated by KB
            response = runtime_client.retrieve_and_generate(
                input={
                    'text': input_text
                },
                retrieveAndGenerateConfiguration={
                    'type': 'KNOWLEDGE_BASE',
                    'knowledgeBaseConfiguration': {
                        'knowledgeBaseId': kb_id,
                        'modelArn': model_arn
                    }
                },
                sessionId=session_id_kb
            )
        else:
            # This is a first call to KB, we don't have session_id yet
            response = runtime_client.retrieve_and_generate(
                input={
                    'text': input_text
                },
                retrieveAndGenerateConfiguration={
                    'type': 'KNOWLEDGE_BASE',
                    'knowledgeBaseConfiguration': {
                        'knowledgeBaseId': kb_id,
                        'modelArn': model_arn
                    }
                }
            )
            
            
        completion = response['output']['text']
        
        contexts=[]
        for citation in response["citations"]:
            retrievedReferences = citation["retrievedReferences"]
            for reference in retrievedReferences:
                 contexts.append(reference["content"]["text"])
                 
        # preserve session id generated by KB, will use it on subsequent calls
        session_id_kb = response["sessionId"]

    else:
    
        # Using Agent
        
        response = runtime_client.invoke_agent(
            agentId=agent_id,
            agentAliasId=agent_alias_id,
            sessionId=session_id,
            inputText=input_text,
        )
    
        completion = ""
    
        for event in response.get("completion"):
            chunk = event["chunk"]
            completion += chunk["bytes"].decode()

    
    return {
        "sessionState": {
            "dialogAction": {
                "type": "Close"
            },
            "intent": {
                "name": "FallbackIntent",
                "state": "Fulfilled"
            },
            "sessionAttributes": {
                "sessionId_kb": session_id_kb
            }

        },
        "messages": [
                {
                    "contentType": "PlainText",
                    "content": completion
                }
        ]
    }